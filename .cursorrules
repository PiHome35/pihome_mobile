# Flutter Clean Architecture with BLoC Pattern Coding Rules

## 1. Project Structure
- lib/
  |-- config/
  ├── core/              # Shared code across features
  │   ├── error/         # Error handling
  │   ├── resources/     # resources /share
  │   └── utils/         # Utility functions
  ├── features/          # Feature-based modules
  │   └── feature_name/  # Each feature follows clean architecture
  │       ├── data/      # Data layer
  │       ├── domain/    # Domain layer
  │       └── presentation/ # Presentation layer
  └── main.dart

## 2. Clean Architecture Layers
### 2.1 Data Layer
- Implement repositories return type with DataState<T>
- Define data models (DTOs)
- pefer model class extends from entities
- implement toJson , toEntity in model class  
- Handle external data sources
- Convert DTOs to domain entities
- use dio for network
- Use return dataState (DataFail or DataSuccess) for response from network response


### 2.2 Domain Layer
- Define entities
- extend Equatable in class entities
- Define repository interfaces (abstract class) return type with DataState<T>
- Implement use cases by implement usecase abstract class is in core/usecase.dart
- Business logic resides here

### 2.3 Presentation Layer
- Implement BLoC pattern
- UI components
- Screen/Page widgets
- No direct data layer access

## 3. BLoC Pattern Rules
### 3.1 Structure
- One BLoC per feature
- Keep Bussiness Logic in Bloc
- States should be immutable
- Events should be descriptive
- Follow naming convention:
  - bloc/remote (for remote)
      - {feature}_remote_bloc
      - {feature}_remote_event
      - {feature}_remote_state
    - bloc/local (for local)
      - {feature}_local_bloc
      - {feature}_local_event
      - {feature}_local_state 


### 3.2 Implementation
- Use sealed classes for events and states
- Keep BLoCs focused and single-responsibility
- Implement proper error handling
- Dispose BLoCs properly
- Use injectable for dependency injection

### 3.3 State Management
- Avoid business logic in UI
- Use BlocBuilder for UI updates
- Use BlocListener for side effects
- Use BlocConsumer when both are needed

## 4. Dependency Rules
- Domain layer has no external dependencies
- Data layer depends on domain layer
- Presentation layer depends on domain layer
- No circular dependencies
- Use dependency injection

## 5. Coding Standards
### 5.1 General
- Follow Dart style guide
- pefer composition over inheritance
- Use meaningful names
- Write unit tests for all layers
- Document public APIs
- perfer a log than debugPrint

### 5.2 File Naming
- snake_case for files
- feature_bloc.dart
- feature_event.dart
- feature_state.dart
- i_feature_repository.dart

### 5.3 Error Handling
- Use Result type for operations
- Handle all possible errors
- Proper error messages
- Implement error reporting
- use try catch for async operation
### 5.4 routing
- Use GoRouter for navigate in App

## 6. Testing
### 6.1 Required Tests
- Unit tests for BLoCs
- Unit tests for use cases
- Unit tests for repositories
- Widget tests for UI components

### 6.2 Test Rules
- Mock external dependencies
- Test error scenarios
- Test edge cases
- Maintain high coverage

## 7. Performance
- Lazy load when possible
- Implement proper caching
- Optimize UI rebuilds
- Monitor memory usage

## 8. Version Control
- Feature branch workflow
- Meaningful commit messages
- Regular code reviews
- Clean PR descriptions

## 9. Documentation
- README for setup
- API documentation
- Architecture overview
- Update documentation regularly

## 10. Maintenance
- Regular dependency updates
- Code cleanup sprints
- Performance monitoring
- Technical debt tracking


create a UI following style monospace, modern, minimal
